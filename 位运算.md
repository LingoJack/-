# 位运算

## 二进制中的原码、反码、补码

### **有符号数**

>对于有符号数而言，符号的正、负机器是无法识别的，但由于“正、负”恰好是两种截然不同的状态，如果用“0”表示“正”，用“1”表示“负”，这样符号也被数字化了，并且规定将它放在有效数字的前面，即组成了有符号数。所以，在二进制中使用最高位（第一位）来表示符号，最高位是0，表示正数；最高位是1，表示负数。

`100000000000000001111100`



### **无符号数**

> 无符号数是针对二进制来讲的，无符号数的表数范围是非负数。全部二进制均代表数值（所有位都用于表示数的大小），没有符号位。即第一个"0"或"1"不表示正负

`000000000000000001111100`



### 有符号数的性质

> (1)二进制的最高位是符号位：0表示正数，1表示负数
>
> (2)正数的原码、反码、补码都一样
>
> (3)负数的反码 = 它的原码符号位不变，其他位取反（0 ->1 ; 1->0 ）
>
> (4)负数的补码 = 它的反码 +1
>
> (5)0的反码、补码都是0
>
> (6)在计算机运算的时候，都是以补码的方式来运算的
>
> (7)对有符号位进行取反操作，不包含其符号位



**运算例子：**

Q：计算机中运算1-2

A：

- 第一步：获取1的补码 `00000000 00000000 00000000 00000001`

- 第二步：获取-2的补码

  - -2的原码：`10000000 00000000 00000000 00000010`

  - -2的反码：`11111111 11111111 11111111 11111101`

  - -2的补码： `11111111 11111111 11111111 11111110`

- 第三步：1的补码与-2的补码相加：

  -    `00000000 00000000 00000000 00000001 `

  + +`11111111 11111111 11111111 11111110`

  - = `11111111 11111111 11111111 11111111`

- 第四步：将计算结果的补码转换为原码，反其道而行之即可（如果想将二进制转换为十进制，必须得到二进制的原码）
  -  补码：`11111111 11111111 11111111 11111111`=
  - 反码：`11111111 11111111 11111111 11111110` =
  - 原码：`10000000 00000000 00000000 00000001`**(也可以直接对补码除符号位取反加一得到原码)**
  -  第五步：将计算结果的二进制原码 转换 为十进制
  - 二进制原码：`10000000 00000000 00000000 00000001` = -1



## 异或运算(^)

**异或运算具有如下性质：**

- $x\oplus 0=x$
- $x\oplus x=0$

- 异或的运算符为^，数学符号为$\oplus$

- 在Java中，异或运算会先把两个数值转换成二进制，然后同位的数值相同为0，不同为1
- **奇数个1异或运算的结果为1，偶数个1异或运算的结果为0**

- $x\oplus y=y\oplus x$
- $(x\oplus y)\oplus z=x\oplus (y\oplus z)$



## 按位与运算（&）

**按位与运算具有如下性质**：

- 在Java中，按位与运算会先把两个数值转换成二进制，同位数值同为1则该位结果为1，否则为0

例如：

- 计算5&3
  - 5的二进制表示`0101`**(实际是int类型会用32位二进制表示，下同)**
  - 3的二进制表示`0011`
  - 同位进行与运算得到`0001`





## 按位或运算（|）

- 在Java中，按位与运算会先把两个数值转换成二进制，同位数值同为0则该位结果为0，否则为1

例如：

- 计算5&3
  - 5的二进制表示`0101`
  - 3的二进制表示`0011`
  - 同位进行或运算得到`0111`





## 按位非运算（~）

- 在Java中，按位与运算会先把数值转换成二进制，依次对每一位取反

例如：

- 计算~5
  - 5的二进制表示`0101`
  - 对每一位进行非运算得到`1010`



## 左位移运算符（<<）

> 符号位不变，低位补0。移几位补几个0。正数或者负数左移，低位都是用0补。



## 右移运算符（>>）

>如果值为正，则在高位补0，如果值为负，则在高位补1。



## 无符号右移运算符（>>>）

> 无符号的意思是将符号位当作数字位看待，即无论值的正负，都在高位补0。



## 位运算符结合赋值操作

~~~java
 &= 按位与赋值
 |= 按位或赋值
 ^= 按位非赋值
 >>= 右移赋值
 >>>= 无符号右移赋值
 <<= 赋值左移
~~~

这些操作和 `+=` 一个概念



## 位运算的妙用

### 取绝对值

~~~java
 |a| = (a^(a>>31))-(a>>31)
~~~

**解释**：

a>>31取得a的符号，若a为正数，a>>31等于0，a^0=a，不变；若a为负数,a>>31等于-1 ，a^-1翻转每一位。



### 不用临时变量交换两个数

~~~java
int a = 1, b = 2;
a ^= b;//a=1^2
b ^= a;//b=2^1^2=1
a ^= b;//a=1^2^2^1^2=2
// 现在 a = 2, b = 1
~~~

- 利用了性质$a\oplus b \oplus a=b$	



### 判断一个数的奇偶性

~~~java
n&1 == 1?”奇数”:”偶数”
~~~

**解释**：

- n被转化为32位二进制表示
- 1被转化为32位二进制表示`0000 0000 0000 0000 0000 0000 0000 0001`
- n与1同位与运算，这样就取出了n的最低位值，若最低位为1，说明为奇数，否则为偶数



### 转换英文大小写

- 利用或操作 | 和空格将英文字符转换为小写

~~~java
('a' | ' ') = 'a'
('A' | ' ') = 'a'
~~~

- 利用与操作 & 和下划线将英文字符转换为大写

~~~java
('b' & '_') = 'B'
('B' & '_') = 'B'
~~~

- 利用异或操作 ^ 和空格进行英文字符大小写互换

~~~java
('d' ^ ' ') = 'D'
('D' ^ ' ') = 'd'
~~~



### 确定最低位的1的位置

可以用`x&-x`来确定x的二进制表示中最低位1的位置

**例子**：

~~~java
public class LowestSetBitPosition {
    public static void main(String[] args) {
        int x = 20;  // 二进制表示为10100，最低位的1是第2位（从右往左，从0开始计数）
        int result = x & -x;
        int position = findLowestSetBitPosition(x);

        System.out.println("x的二进制表示: " + Integer.toBinaryString(x));
        System.out.println("x & -x: " + Integer.toBinaryString(result));
        System.out.println("x的最低位1在位置: " + position);
    }

    public static int findLowestSetBitPosition(int x) {
        if (x == 0) {
            return -1;  // 如果x为0，没有最低位的1
        }

        int position = 0;
        while ((x & 1) == 0) {
            x >>= 1;
            position++;
        }

        return position;
    }
}

~~~

将输出

~~~java
x的二进制表示: 10100//（从右往左，从0开始计数）
x & -x: 100
x的最低位1在位置: 2
~~~



